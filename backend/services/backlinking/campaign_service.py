"""
Campaign Management Service for Backlinking

Handles database operations for backlinking campaigns, opportunities, and email tracking.
Manages campaign lifecycle, analytics, and data persistence.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime
from sqlalchemy.orm import Session
from loguru import logger

from services.database import SessionLocal
from .backlinking_service import BacklinkingCampaign, BacklinkOpportunity
from .database_service import BacklinkingDatabaseService


# Database models would be defined in models/backlinking.py
# For now, we'll use mock data structures

@dataclass
class CampaignRecord:
    """Database record for a backlinking campaign."""
    id: str
    user_id: int
    name: str
    keywords: List[str]
    status: str
    created_at: datetime
    updated_at: datetime
    user_proposal: Dict[str, Any]
    email_stats: Dict[str, int]


@dataclass
class OpportunityRecord:
    """Database record for a backlinking opportunity."""
    id: int
    campaign_id: str
    url: str
    title: str
    description: str
    contact_email: Optional[str]
    contact_name: Optional[str]
    domain_authority: Optional[int]
    content_topics: List[str]
    submission_guidelines: Optional[str]
    status: str
    discovered_at: datetime
    contacted_at: Optional[datetime]
    responded_at: Optional[datetime]


@dataclass
class EmailRecord:
    """Database record for an email."""
    id: int
    campaign_id: str
    opportunity_id: str
    recipient_email: str
    subject: str
    body: str
    status: str
    sent_at: Optional[datetime]
    follow_up_count: int


class CampaignManagementService:
    """
    Service for managing backlinking campaigns and related data.

    Handles CRUD operations for campaigns, opportunities, and emails,
    as well as analytics and reporting.
    """

    def __init__(self):
        self.db_service = BacklinkingDatabaseService()

    async def create_campaign(
        self,
        user_id: int,
        name: str,
        keywords: List[str],
        user_proposal: Dict[str, Any]
    ) -> BacklinkingCampaign:
        """
        Create a new backlinking campaign.

        Args:
            user_id: User ID
            name: Campaign name
            keywords: Target keywords
            user_proposal: User's guest post proposal

        Returns:
            Created campaign
        """
        try:
            campaign_data = {
                "name": name,
                "keywords": keywords,
                "status": "active",
                "user_proposal": user_proposal,
                "ai_model_preference": "gemini",
                "tone_preference": "professional",
                "personalization_level": "high",
                "max_opportunities": 100,
                "max_emails_per_day": 10,
                "max_follow_ups": 3,
                "estimated_cost": 0.0,
                "actual_cost": 0.0,
                "total_opportunities": 0,
                "contacted_opportunities": 0,
                "responded_opportunities": 0,
                "successful_links": 0,
            }

            campaign = await self.db_service.create_campaign(user_id, campaign_data)

            # Convert to our service model
            return BacklinkingCampaign(
                campaign_id=campaign.id,
                user_id=campaign.user_id,
                name=campaign.name,
                keywords=campaign.keywords,
                status=campaign.status,
                created_at=campaign.created_at,
                opportunities=[],  # Will be populated when needed
                email_stats={"sent": 0, "replied": 0, "bounced": 0}  # Will be calculated from actual data
            )

        except Exception as e:
            logger.error(f"Failed to create campaign: {e}")
            raise

    async def add_opportunities(
        self,
        campaign_id: str,
        opportunities: List[BacklinkOpportunity]
    ) -> None:
        """
        Add discovered opportunities to a campaign.

        Args:
            campaign_id: Campaign ID
            opportunities: List of opportunities to add
        """
        try:
            for opportunity in opportunities:
                opportunity_record = OpportunityRecord(
                    id=0,  # Would be auto-generated by DB
                    campaign_id=campaign_id,
                    url=opportunity.url,
                    title=opportunity.title,
                    description=opportunity.description,
                    contact_email=opportunity.contact_email,
                    contact_name=opportunity.contact_name,
                    domain_authority=opportunity.domain_authority,
                    content_topics=opportunity.content_topics or [],
                    submission_guidelines=opportunity.submission_guidelines,
                    status=opportunity.status,
                    discovered_at=datetime.now(),
                    contacted_at=None,
                    responded_at=None
                )

                # In production: self.db.add(opportunity_record)

            # In production: self.db.commit()
            logger.info(f"Added {len(opportunities)} opportunities to campaign {campaign_id}")

        except Exception as e:
            logger.error(f"Failed to add opportunities: {e}")
            raise

    async def save_generated_email(
        self,
        campaign_id: str,
        opportunity_id: str,
        email_content: str
    ) -> EmailRecord:
        """
        Save a generated email to the database.

        Args:
            campaign_id: Campaign ID
            opportunity_id: Opportunity URL/ID
            email_content: Generated email content

        Returns:
            Email record
        """
        try:
            # Parse email content to extract subject and body
            lines = email_content.strip().split('\n')
            subject = ""
            body = ""

            if lines and lines[0].startswith('Subject:'):
                subject = lines[0].replace('Subject:', '').strip()
                body = '\n'.join(lines[1:]).strip()
            else:
                body = email_content

            email_record = EmailRecord(
                id=0,  # Would be auto-generated
                campaign_id=campaign_id,
                opportunity_id=opportunity_id,
                recipient_email="",  # Would be populated from opportunity
                subject=subject,
                body=body,
                status="generated",
                sent_at=None,
                follow_up_count=0
            )

            # In production: self.db.add(email_record); self.db.commit()

            logger.info(f"Saved generated email for campaign {campaign_id}")
            return email_record

        except Exception as e:
            logger.error(f"Failed to save generated email: {e}")
            raise

    async def update_email_stats(
        self,
        campaign_id: str,
        sent_count: int = 0,
        replied_count: int = 0,
        bounced_count: int = 0
    ) -> None:
        """
        Update email statistics for a campaign.

        Args:
            campaign_id: Campaign ID
            sent_count: Number of emails sent
            replied_count: Number of replies received
            bounced_count: Number of bounced emails
        """
        try:
            # In production: Query and update campaign email stats
            # campaign = self.db.query(CampaignRecord).filter_by(id=campaign_id).first()
            # if campaign:
            #     campaign.email_stats['sent'] += sent_count
            #     campaign.email_stats['replied'] += replied_count
            #     campaign.email_stats['bounced'] += bounced_count
            #     self.db.commit()

            logger.info(f"Updated email stats for campaign {campaign_id}")

        except Exception as e:
            logger.error(f"Failed to update email stats: {e}")
            raise

    async def get_campaign_opportunities(self, campaign_id: str) -> List[BacklinkOpportunity]:
        """
        Get all opportunities for a campaign.

        Args:
            campaign_id: Campaign ID

        Returns:
            List of opportunities
        """
        try:
            opportunities = await self.db_service.get_campaign_opportunities(campaign_id)

            # Convert to service model
            return [
                BacklinkOpportunity(
                    url=opp.url,
                    title=opp.title,
                    description=opp.description,
                    contact_email=opp.contact_email,
                    contact_name=opp.contact_name,
                    domain_authority=opp.domain_authority,
                    content_topics=opp.primary_topics or [],
                    submission_guidelines=opp.submission_guidelines,
                    status=opp.status
                )
                for opp in opportunities
            ]

        except Exception as e:
            logger.error(f"Failed to get campaign opportunities: {e}")
            raise

    async def find_opportunity_by_email(
        self,
        campaign_id: str,
        email: str
    ) -> Optional[BacklinkOpportunity]:
        """
        Find an opportunity by contact email.

        Args:
            campaign_id: Campaign ID
            email: Contact email to search for

        Returns:
            Opportunity if found, None otherwise
        """
        try:
            opportunities = await self.get_campaign_opportunities(campaign_id)

            for opportunity in opportunities:
                if opportunity.contact_email == email:
                    return opportunity

            return None

        except Exception as e:
            logger.error(f"Failed to find opportunity by email: {e}")
            return None

    async def update_opportunity_status(
        self,
        campaign_id: str,
        opportunity_url: str,
        status: str
    ) -> None:
        """
        Update the status of an opportunity.

        Args:
            campaign_id: Campaign ID
            opportunity_url: Opportunity URL
            status: New status
        """
        try:
            # In production: Update opportunity status in database
            # opportunity = self.db.query(OpportunityRecord).filter_by(
            #     campaign_id=campaign_id, url=opportunity_url
            # ).first()
            # if opportunity:
            #     opportunity.status = status
            #     if status == "responded":
            #         opportunity.responded_at = datetime.now()
            #     self.db.commit()

            logger.info(f"Updated opportunity status: {opportunity_url} -> {status}")

        except Exception as e:
            logger.error(f"Failed to update opportunity status: {e}")
            raise

    async def get_campaign_analytics(self, campaign_id: str) -> Dict[str, Any]:
        """
        Get analytics data for a campaign.

        Args:
            campaign_id: Campaign ID

        Returns:
            Analytics data
        """
        try:
            # In production: Calculate analytics from database
            opportunities = await self.get_campaign_opportunities(campaign_id)

            analytics = {
                "total_opportunities": len(opportunities),
                "opportunities_by_status": {},
                "email_stats": {
                    "sent": 0,
                    "replied": 0,
                    "bounced": 0,
                    "open_rate": 0.0,
                    "reply_rate": 0.0
                },
                "top_performing_opportunities": [],
                "campaign_progress": {
                    "discovery_complete": True,
                    "emails_generated": True,
                    "emails_sent": False,
                    "responses_checked": False
                }
            }

            # Count opportunities by status
            for opp in opportunities:
                status = opp.status
                analytics["opportunities_by_status"][status] = \
                    analytics["opportunities_by_status"].get(status, 0) + 1

            # Calculate reply rate
            sent = analytics["email_stats"]["sent"]
            replied = analytics["email_stats"]["replied"]
            if sent > 0:
                analytics["email_stats"]["reply_rate"] = (replied / sent) * 100

            return analytics

        except Exception as e:
            logger.error(f"Failed to get campaign analytics: {e}")
            raise

    async def get_user_campaigns(self, user_id: int) -> List[BacklinkingCampaign]:
        """
        Get all campaigns for a user.

        Args:
            user_id: User ID

        Returns:
            List of user's campaigns
        """
        try:
            campaigns = await self.db_service.get_user_campaigns(user_id)

            # Convert to service model
            return [
                BacklinkingCampaign(
                    campaign_id=campaign.id,
                    user_id=campaign.user_id,
                    name=campaign.name,
                    keywords=campaign.keywords,
                    status=campaign.status,
                    created_at=campaign.created_at,
                    opportunities=[],  # Will be populated separately if needed
                    email_stats={"sent": 0, "replied": 0, "bounced": 0}  # Will be calculated from actual data
                )
                for campaign in campaigns
            ]

        except Exception as e:
            logger.error(f"Failed to get user campaigns: {e}")
            raise

    async def pause_campaign(self, campaign_id: str) -> None:
        """
        Pause a campaign.

        Args:
            campaign_id: Campaign ID
        """
        try:
            # In production: Update campaign status
            logger.info(f"Paused campaign: {campaign_id}")
        except Exception as e:
            logger.error(f"Failed to pause campaign: {e}")
            raise

    async def resume_campaign(self, campaign_id: str) -> None:
        """
        Resume a paused campaign.

        Args:
            campaign_id: Campaign ID
        """
        try:
            # In production: Update campaign status
            logger.info(f"Resumed campaign: {campaign_id}")
        except Exception as e:
            logger.error(f"Failed to resume campaign: {e}")
            raise

    async def delete_campaign(self, campaign_id: str) -> None:
        """
        Delete a campaign and all related data.

        Args:
            campaign_id: Campaign ID
        """
        try:
            # In production: Delete campaign and related records
            logger.info(f"Deleted campaign: {campaign_id}")
        except Exception as e:
            logger.error(f"Failed to delete campaign: {e}")
            raise