"""YouTube Assets Router

Handles video asset management, file serving, and cost estimation endpoints.
Provides access to generated videos, cost calculations, and asset library integration.
"""

from pathlib import Path
from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from middleware.auth_middleware import get_current_user
from services.database import get_db
from models.content_asset_models import AssetType, AssetSource

from .models import VideoListResponse, CostEstimateRequest, CostEstimateResponse
from .utils import require_authenticated_user
from .dependencies import get_youtube_renderer_service, get_content_asset_service
from .constants import YOUTUBE_VIDEO_DIR

from utils.logger_utils import get_service_logger

logger = get_service_logger("api.youtube.assets")

router = APIRouter(prefix="", tags=["youtube-assets"])


@router.get("/videos", response_model=VideoListResponse)
async def list_videos(
    current_user: Dict[str, Any] = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> VideoListResponse:
    """
    List videos for the current user from the asset library (source: youtube_creator).

    Used to rescue/persist scene videos after reloads.
    Returns videos with metadata like scene number, resolution, and creation date.
    """
    try:
        user_id = require_authenticated_user(current_user)
        asset_service = get_content_asset_service()

        assets, _ = asset_service.get_user_assets(
            user_id=user_id,
            asset_type=AssetType.VIDEO,
            source_module=AssetSource.YOUTUBE_CREATOR,
            limit=100,
        )

        videos = []
        for asset in assets:
            try:
                videos.append({
                    "scene_number": asset.asset_metadata.get("scene_number") if asset.asset_metadata else None,
                    "video_url": asset.file_url,
                    "filename": asset.filename,
                    "created_at": asset.created_at.isoformat() if asset.created_at else None,
                    "resolution": asset.asset_metadata.get("resolution") if asset.asset_metadata else None,
                })
            except Exception as asset_error:
                logger.warning(f"[YouTubeAssets] Error processing asset {asset.id if hasattr(asset, 'id') else 'unknown'}: {asset_error}")
                continue  # Skip this asset and continue with others

        logger.info(f"[YouTubeAssets] Listed {len(videos)} videos for user {user_id}")
        return VideoListResponse(videos=videos)

    except Exception as e:
        logger.error(f"[YouTubeAssets] Error listing videos: {e}", exc_info=True)
        # Return empty list on error rather than failing completely
        return VideoListResponse(videos=[], success=False, message=f"Failed to list videos: {str(e)}")


@router.post("/estimate-cost", response_model=CostEstimateResponse)
async def estimate_render_cost(
    request: CostEstimateRequest,
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> CostEstimateResponse:
    """
    Estimate the cost of rendering a video before actually rendering it.

    This endpoint calculates the expected cost based on:
    - Number of enabled scenes
    - Duration of each scene
    - Selected resolution and image model

    Returns a detailed cost breakdown for informed decision making.
    """
    try:
        require_authenticated_user(current_user)

        logger.info(
            f"[YouTubeAssets] Estimating cost: {len(request.scenes)} scenes, "
            f"resolution={request.resolution}"
        )

        renderer = get_youtube_renderer_service()
        estimate = renderer.estimate_render_cost(
            scenes=request.scenes,
            resolution=request.resolution,
            image_model=request.image_model,
        )

        return CostEstimateResponse(
            success=True,
            estimate=estimate,
            message="Cost estimate calculated successfully"
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[YouTubeAssets] Error estimating cost: {e}", exc_info=True)
        return CostEstimateResponse(
            success=False,
            message=f"Failed to estimate cost: {str(e)}"
        )


@router.get("/videos/{video_filename}")
async def serve_youtube_video(
    video_filename: str,
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> FileResponse:
    """
    Serve YouTube video files.

    This endpoint serves video files generated by the YouTube Creator Studio.
    Videos are stored in the youtube_videos directory with security validation.
    """
    try:
        require_authenticated_user(current_user)

        # Security: prevent directory traversal
        if ".." in video_filename or "/" in video_filename or "\\" in video_filename:
            raise HTTPException(status_code=400, detail="Invalid filename")

        video_path = YOUTUBE_VIDEO_DIR / video_filename

        if not video_path.exists():
            raise HTTPException(status_code=404, detail="Video not found")

        if not video_path.is_file():
            raise HTTPException(status_code=400, detail="Invalid video path")

        logger.debug(f"[YouTubeAssets] Serving video: {video_filename}")

        return FileResponse(
            path=str(video_path),
            media_type="video/mp4",
            filename=video_filename,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[YouTubeAssets] Error serving video: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to serve video: {str(e)}"
        )